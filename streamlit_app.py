# -*- coding: utf-8 -*-
"""streamlit_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19W5bN73mFsBCZseZS6s3XHBIfH7Hn0X_
"""

# streamlit_app.py
import streamlit as st
import pandas as pd
import numpy as np
from geopy.distance import great_circle
from datetime import datetime, timedelta
from ortools.constraint_solver import pywrapcp, routing_enums_pb2

# === SETUP ===
st.set_page_config(layout="wide")
st.title("ğŸšš Multi-Trip VRP Simulator (Near & Far Orders)")

depot_lat, depot_lon = 12.9716, 77.5946  # Bengaluru Depot

# === Generate Orders ===
num_orders = st.sidebar.slider("Number of Orders", 10, 200, 100, step=10)
@st.cache_data
def generate_orders(num_orders):
    np.random.seed(42)
    orders = pd.DataFrame({
        'order_id': range(1, num_orders+1),
        'latitude': depot_lat + np.random.uniform(-0.03, 0.03, num_orders),
        'longitude': depot_lon + np.random.uniform(-0.02, 0.061, num_orders),
        'volume': np.random.randint(1, 10, num_orders),
        'weight': np.random.randint(1, 20, num_orders)
    })
    orders['distance_from_depot'] = orders.apply(
        lambda row: great_circle((depot_lat, depot_lon), (row['latitude'], row['longitude'])).km, axis=1
    )
    return orders

orders = generate_orders(num_orders)
near_orders = orders[orders['distance_from_depot'] < 5].reset_index(drop=True)
far_orders = orders[orders['distance_from_depot'] >= 5].reset_index(drop=True)

st.sidebar.header("ğŸ§® Parameters")
vehicle_count_near = st.sidebar.slider("Near Vehicles", 1, 5, 3)
vehicle_count_far = st.sidebar.slider("Far Vehicles", 1, 3, 1)
max_orders = st.sidebar.slider("Max Orders per Trip", 1, 5, 3)
volume_capacity = st.sidebar.slider("Vehicle Volume Capacity", 10, 100, 30)
weight_capacity = st.sidebar.slider("Vehicle Weight Capacity", 10, 100, 50)

# === VRP Functions ===
def solve_vrp_with_schedule(df, real_vehicles, max_orders, volume_capacity, weight_capacity, speed_kmh=30, stop_time_min=10):
    required_trips = int(np.ceil(len(df) / max_orders))
    virtual_vehicles = real_vehicles * required_trips
    locations = [(depot_lat, depot_lon)] + list(zip(df['latitude'], df['longitude']))
    distance_matrix = [
        [int(great_circle(a, b).km * 1000) for b in locations] for a in locations
    ]
    volumes = [0] + list(df['volume'])
    weights = [0] + list(df['weight'])
    manager = pywrapcp.RoutingIndexManager(len(distance_matrix), virtual_vehicles, 0)
    routing = pywrapcp.RoutingModel(manager)

    def distance_callback(from_index, to_index):
        return distance_matrix[manager.IndexToNode(from_index)][manager.IndexToNode(to_index)]
    routing.SetArcCostEvaluatorOfAllVehicles(routing.RegisterTransitCallback(distance_callback))

    def volume_callback(from_index): return volumes[manager.IndexToNode(from_index)]
    routing.AddDimensionWithVehicleCapacity(
        routing.RegisterUnaryTransitCallback(volume_callback), 0,
        [volume_capacity] * virtual_vehicles, True, "Volume"
    )

    def weight_callback(from_index): return weights[manager.IndexToNode(from_index)]
    routing.AddDimensionWithVehicleCapacity(
        routing.RegisterUnaryTransitCallback(weight_callback), 0,
        [weight_capacity] * virtual_vehicles, True, "Weight"
    )

    order_demands = [0] + [1] * len(df)
    routing.AddDimensionWithVehicleCapacity(
        routing.RegisterUnaryTransitCallback(lambda idx: order_demands[manager.IndexToNode(idx)]),
        0, [max_orders] * virtual_vehicles, True, "OrderCount"
    )

    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.time_limit.seconds = 3
    search_parameters.first_solution_strategy = routing_enums_pb2.FirstSolutionStrategy.AUTOMATIC
    search_parameters.local_search_metaheuristic = routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH
    solution = routing.SolveWithParameters(search_parameters)

    vehicle_routes = {}
    if solution:
        for vehicle_id in range(virtual_vehicles):
            index = routing.Start(vehicle_id)
            route = []
            while not routing.IsEnd(index):
                route.append(manager.IndexToNode(index))
                index = solution.Value(routing.NextVar(index))
            route.append(manager.IndexToNode(index))
            if len(route) > 2:
                vehicle_routes[vehicle_id] = route
    return create_schedule(vehicle_routes, distance_matrix, virtual_vehicles, real_vehicles, required_trips)

def create_schedule(vehicle_routes, distance_matrix, virtual_vehicle_count, real_vehicle_count, max_trips_per_vehicle, speed_kmh=30, stop_time_min=10):
    schedule = {vehicle_id + 1: [] for vehicle_id in range(real_vehicle_count)}
    start_time = datetime.strptime("09:00", "%H:%M")

    for virtual_vehicle_id, route in vehicle_routes.items():
        real_vehicle_id = (virtual_vehicle_id) % real_vehicle_count + 1
        trip_number = len(schedule[real_vehicle_id]) + 1
        trip_time_minutes = 0
        route_stops = ["Depot"]
        for i in range(len(route) - 1):
            from_node, to_node = route[i], route[i + 1]
            distance_km = distance_matrix[from_node][to_node] / 1000
            trip_time_minutes += (distance_km / speed_kmh) * 60
            if to_node != 0:
                trip_time_minutes += stop_time_min
                route_stops.append(f"Order {to_node}")
        route_stops.append("Depot")
        last_trip_end = schedule[real_vehicle_id][-1]['End Time'] if schedule[real_vehicle_id] else start_time
        trip_start_time = last_trip_end
        trip_end_time = trip_start_time + timedelta(minutes=trip_time_minutes)
        schedule[real_vehicle_id].append({
            'Trip': trip_number,
            'Start Time': trip_start_time,
            'End Time': trip_end_time,
            'Stops': route_stops
        })
    return schedule

# === RUN SIMULATION ===
if st.button("ğŸš€ Run VRP Simulation"):
    with st.spinner("Optimizing routes..."):
        near_schedule = solve_vrp_with_schedule(near_orders, vehicle_count_near, max_orders, volume_capacity, weight_capacity)
        far_schedule = solve_vrp_with_schedule(far_orders, vehicle_count_far, max_orders, volume_capacity, weight_capacity)

    # === DISPLAY RESULTS ===
    st.subheader("ğŸ“ Near Orders Schedule")
    for vehicle_id, trips in near_schedule.items():
        st.markdown(f"### ğŸšš Vehicle {vehicle_id}")
        for trip in trips:
            st.markdown(f"- ğŸ›£ï¸ **Trip {trip['Trip']}**: â° {trip['Start Time'].strftime('%H:%M')} â†’ ğŸ•“ {trip['End Time'].strftime('%H:%M')}")
            st.markdown(f"  - ğŸ“ Route: {' â¡ï¸ '.join(trip['Stops'])}")

    st.subheader("ğŸ“¦ Far Orders Schedule")
    for vehicle_id, trips in far_schedule.items():
        st.markdown(f"### ğŸš› Vehicle {vehicle_id}")
        for trip in trips:
            st.markdown(f"- ğŸ›£ï¸ **Trip {trip['Trip']}**: â° {trip['Start Time'].strftime('%H:%M')} â†’ ğŸ•“ {trip['End Time'].strftime('%H:%M')}")
            st.markdown(f"  - ğŸ“ Route: {' â¡ï¸ '.join(trip['Stops'])}")

